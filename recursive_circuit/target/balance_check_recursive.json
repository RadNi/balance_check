{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"7214993913830777961","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":128,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":459,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":97,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/7XbdZhUhQKG8TMDSIkF2CJi98wG7Bq4YoutdC8s3d3d3d3dZRcittidiNjdrXjv65m593VA/4DZ8zw6v93Fw5mzwzp+32ckCI/N0SAoE+x5RBKPeYnHzFjlrKyCKhkF8cx4k1hGbn5OdiwrO79yTjwnnp2T3SwjJzOzICcrp0pufm6VWG48K7Mg3jw7N7N5LDzWRv9/rth+Hlxb6f/+NTDlWncnHJGjchG5qFxMPkAuLpeQS8ql5NLygXIZ+SD5YPkQ+VD5MLmsXE4uLx8uHyEfKR8lHy0fIx8rHydXkI+XK8onyJXkE+WT5JPlU+RT5dPk0+Uz5DPls+Sz5XPkc+WYHJcz5Ew5S86WK8tV5Bw5Vz5PPl++QL5QripfJOfJF8vV5EvkS+XL5MvlK+Qr5avkq+Xq8jXytfJ18vXyDfKN8k3yzfItcg25plxLri3XkevK9eT6cgO5odxIbiw3kfPlpnIzuUBuLreQW8qt5NZyG7mt3E5uL3eQO8qd5M5yF7mr3E3uLveQe8q95N5yH7mv3E/uLw9IeDsfJD43UF8fJA+Wh8hD5WHycHmEPFIeJY+Wx8hj5XHyeHmCPFGeJE+Wp8hT5WnydHmGPFOeJc+W58hz5XnyfHmBvFBeJC+Wl8hL5WXycnmFvFJeJa+W18hr5XXyenmDvFHeJG+Wb5Vvk2+X75DvlO+S75bvke+V75Pvl7fID8hb5QflbfJD8sPyI/Kj8mPy4/IT8pPydvkp+Wn5GflZ+Tn5efkF+UX5Jfll+RX5Vfk1+XX5DflN+S35bXmH/I68U35X3iW/J78vfyB/KH8kfyx/In8qfyZ/Ln8hfyl/JX8tfyN/K38nfy//IP8o/yT/LP8i/yr/Jv8u/yHvlv+U+VvSETkqF5GLysXkA+Ticgm5pFxKLi0fKJeRD5IPlg+RD5UPk8vK5eTy8uHyEfKR8lHy0fIx8rHycXIF+Xi5onyCXEk+UT5JPlk+RT5VPk0+XT5DPlM+Sz5bPkc+V47JcTlDzpSz5Gy5slxFzpFz5fPk8+UL5AvlqvJFcp58sVxNvkS+VL5Mvly+Qr5Svkq+Wq4uXyNfK18nXy/fIN8o3yTfLN8i15BryrXk2nIdua5cT64vN5Abyo3kxnITOV9uKjeTC+Tmcgu5pdxKbi23kdvK7eT2cge5o9xJ7ix3kbvK3eTucg+5p9xL7i33kfvK/eT+8gB5oDxIHiwPkYfKw+Th8gh5pDxKHi2PkcfK4+Tx8gR5ojxJnixPkafK0+Tp8gx5pjxLni3PkefK8+T58gJ5obxIXiwvkZfKy+Tl8gp5pbxKXi2vkdfK6+T18gZ5o7xJ3izfKt8m3y7fId8p3yXfLd8j3yvfJ98vb5EfkLfKD8rb5Ifkh+VH5Eflx+TH5SfkJ+Xt8lPy0/Iz8rPyc/Lz8gvyi/JL8svyK/Kr8mvy6/Ib8pvyW/Lb8g75HXmn/K68S35Pfl/+QP5Q/kj+WP5E/lT+TP5c/kL+Uv5K/lr+Rv5W/k7+Xv5B/lH+Sf5Z/kX+Vf5N/l3+Q94t/ykT+CcdkaNyEbmoXEw+QC4ul5BLyqXk0vKBchn5IPlg+RD5UPkwuaxcTi4vHy4fIR8pHyUfLR8jHysfJ1eQj5cryifIleQT5ZPkk+VT5FPl0+TT5TPkM+Wz5LPlc+Rz5ZgclzPkTDlLzpYry1XkHDlXPk8+X75AvlCuKl8k58kXy9XkS+RL5cvky+Ur5Cvlq+SrE24ShAefq66vXyNfK18nXy/fIN8o3yTfLN8i15BryrXk2nIdua5cT64vN5Abyo3kxnITOV9uKjeTC+Tmcgu5pdxKbi23kdvK7eT2cge5o9xJ7ix3kbvK3eTucg+5p9xL7i33kfvK/eT+8gB5oDxIHiwPkYfKw+Th8gh5pDxKHi2PkcfK4+Tx8gR5ojxJnixPkafK0+Tp8gx5pjxLni3PkefK8+T58gJ5obxIXiwvkZfKy+Tl8gp5pbxKXi2vkdfKdP8c0WDPI5J4zEs8xvbviPMaSNO5Ynu53P09dzwJ34t1iQ/WRxM3pEjikS/sSLmAIoV4w/ZxdJKRGJ3E10XTN2BZX0jfyGjK/dvf60znc96wl+e8r+f062hD4nVUNPFxJNjziBTifUnHc0keG6OFeMGcPPUFsr8XvzF9L+T4pjS+2ArrHnKNkTTfw01p/mHwT9/jfTzi6xPPO53f503RNF5n87+OgnS+fjan8XviH1act2Lw9yPd7xLWp+E+FCTuqd/hVI/+/ZqjiefF11k9snZk5ci6kVUja0ZWjKwXWS2yVmSlyDqRVSJrRFaIrA9ZHbI2ZGXIupBVIWtCVoSsB1kNVgjClWDFIFwFVgrCFSDrP1Z/rP1Y+bHuY9XHmo8VH+s9Vnus9Vjp8YeEVR5rPFZ4rO9Y3bG2Y2XHuo5VHWs6VnSs51jNVQ3ClVxeEK7iqgXhCo71G6s31m6s3Fi3sWpjzcaKjfUaqzXWaqzUWKexSmONxgqN9RmrM9ZmrMxYl7EqY03Gioz1GKuxhkG4EmschP9lnB+EKzDWX6y+WHux8mLdxaqLNRcrLtZbrLZYa7HSYp3FKos1Fiss1lesrlhbsbJiXcWqijUVKyrWU6ym+gfhSmpgEK6hBgfh+onVE2snVk6sm1g1sWZixcR6idUSayVWSqyTWCWxRmKFxPqI1RFrI1ZGrItYFbEmYkXEeojVEGuh+UG4DloYhGugxUG4/mH1w9qHlQ/rHlY9rHlY8bDeYbXDWoeVDuscVjmscVjhsL5hdcPahpUN6xpWNaxpWNGwnmE1w1pmSxCuY7YG4RpmWxCuX1i9sHZh5cK6hVULaxZWLKxXWK2wVmGlwjqFVQprFFYorE9YnbA2YWXCuoRVCWsSViSsR1iNsBbhTQ7rkJ1BuAbZFYTrD1YfrD1YebDuYNXBmoMVB+sNVhusNVhpsM5glcEagxUG6wtWF6wtWFmwrmBVwZqCFQXrCVYTybUE6wj+8LOGYAXB+oHVA2sHVg6sG1g1sGZgxcB6gdUCawVWCqwTWCWwRmCFwPqA1QFrA1YGrAtYFbAmYEXAeoDVAGsBVgKsAypGwjUAKwDaf1p/2n5aftp9Wn3afFp82ntae9p6WnraeX4g08bTwvPui9adtp2WnXadVp02nRad9pzWnLaclpx2PC8StuG04LTftN603bTctNu02rTZtNi017TWtNW01LTTtNK00bTQtM+0zrTNtMy0y7TKtMm0yLTHtMa0xbTEtMONI2EbTAtM+0vryw9qWl7aXVpd2lxaXNpbWlvaWlpa2llaWdpYWljaV1pX2lZaVtpVWlXaVFpU2lNaU9pSWlLa0YGRsA2lBaX9pPWk7aTlpN2k1aTNpMWkvaS1pK2kpaSdpJWkjaSFpH2kdaRtpGWkXaRVpE2kRaQ9pDWkLaQlpB1cGAnbQFpA2j9aP9o+Wj7aPVo92jxaPNo7WjvaOlo62jlaOdo4WjjaN1o32jZaNto1WjXaNFo02jNaM9oyWjLasa2RsA2jBaP9ovWi7aLlot2i1aLNosWivaK1oq2ipaKdopWijaKFon2idaJtomWiXaJVok2iRaI9ojWiLaIloh3aGQnbIFog2h9aH9oeWh7aHVod2hxaHNobWhvaGloa2hlaGdoYWhjaF1oX2hZaFtoVWhXaFFoU2hNak7/akkjYjvAvftoQWhDaD1oP2g5aDtoNWg3aDFoM2gtaC9oKWgraCVoJ2ghaCNoHWgfaBloG2gVaBdoEWgTaA1oD2gJaAtoBWgHaAFoA0n9Sf9J+Un7SfVJ90nxSfNJ7UnvSelJ60nniCdJ4UnjSd1J30nZSdtJ1UnXSdFJ00nNSc9JyUnLScVJx0nBScNJvUm/SblJu0m1SbdJsUuwmQXjw3onUmrSalJp0mlSaNJoUmvSZ1Jm0mZSZdJlUmTSZFJn0mNSYtJiUmHSYVJg0mBSY9JfUl7SXlJd0l1SXNJcUl/SW1Ja0lpSWdJZUljSWFJb0ldSVtJWUlXSVVJU0lRSV9JTUlLSUlJR0lFSUNJQUlPST1JO0k5STdJNUkzSTFJMghtSStJKUknSSVJI0khSS9JHUkbSRlJF0kVSRNJEUkfSQ1JC0kJSQdJBUkDSQFJD0j9SPtI+Uj3SPVI80jxSP9C71SH6qROKxZOKxVOKRlzrvb/MSH8f278hInr904Zw/VnzPp/i/5+LfN/X5F93LPxf5h4+jKY//9mtTP+/P7e3/Ekues2zi0debfB4lUx7L67xpvJfx5PnLFc759/q9Ki+XS3mevt95abqG5PmSoWuxYM8jmvK15K9N/TMTSf/1xVOvpchefq/kkXzNlNPnkvfzP/HsLv+eOAAA","debug_symbols":"nZLBqsMgEEX/ZdZZaNSkza88HsEkpghigtUHj5B/72Ra22YRKN3cUWfu4YKzwGC6dGmtH6crND8LdME6Zy+tm3od7eTxdVkLyNc2BmPwCd766Jp1MD5C45NzBfxpl2joOmtPNeqAXVaA8QNWBI7Wme20Fi83O7aWXGZ3KdgLoPYEfkzglVAPAq/56Ukoy48zSF7lDFKIowyfEiT7inCWmaB4vSP84k33Nuz+DhhOFsBJS2jQLUglqSKtSGvSE+mZlLN74feCdrVu2YLVnTOP1RiT7982Jf7PuZN3aQ5Tb4YUzJaMepj1Bg==","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"global MAX_PATH_LEANTH: u32 = 3;\n\nglobal HONK_VK_SIZE: u32 = 128;\nglobal HONK_PROOF_SIZE: u32 = 459;\nglobal HONK_IDENTIFIER: u32 = 1;\n\nstruct Node {\n    rows: [[u8; 32]; 16],\n    row_exist: [bool; 16],\n    node_type: u8\n}\n\nfn calculate_branch_hash(node: Node) -> [u8; 32] {\n    let mut len1: u8 = 0;\n    let mut len2: u8 = 0;\n    let mut encoded: [u8; 532] = [0; 532];\n    let mut index: u32 = 0;\n    for i in 0 .. 16 {\n        if node.row_exist[i] == true {\n            if len2 > 255 - 33 {\n                len1 += 1;\n                len2 = len2 - 223;\n            } else {\n                len2 += 33;\n            }\n        } else {\n            if len2 == 255 {\n                len2 = 0;\n                len1 += 1;\n            } else {\n                len2 += 1;\n            }\n        }\n    }\n    if len2 == 255 {\n        len2 = 0;\n        len1 += 1;\n    } else {\n        len2 += 1;\n    }\n    if (len1 == 0) & (len2 <= 55) {\n        encoded[index] = 0xc0 + len2;\n        index += 1;\n    } else if len1 == 0 {\n        encoded[index] = 0xf8;\n        index += 1;\n        encoded[index] = len2;\n        index += 1;\n    } else {\n        encoded[index] = 0xf9;\n        index += 1;\n        encoded[index] = len1;\n        index += 1;\n        encoded[index] = len2;\n        index += 1;\n    }\n\n    for i in 0 .. 16 {\n        if node.row_exist[i] == true {\n            encoded[index] = 0xa0;\n            index += 1;\n            for j in 0 .. 32 {\n                encoded[index] = node.rows[i][j];\n                index += 1;\n            }\n        } else {\n            encoded[index] = 0x80;\n            index += 1;\n        }\n    }\n    encoded[index] = 0x80;\n    index += 1;\n    keccak256::keccak256(encoded, index)\n\n}\n\nfn main(\n    // nodes: [Node; MAX_PATH_LEANTH], \n    // node_length: u32,\n    // trie_key: pub [u8; 32],\n    // new_root: pub [u8; 32], \n    // trie_key_new_index: u8,\n\n\n    verification_key: [Field; HONK_VK_SIZE],\n    proof: [Field; HONK_PROOF_SIZE],\n    public_inputs: pub [Field; 97]\n    // root: pub [u8; 32], \n    // trie_key: pub [u8; 32], \n    // trie_key_new_index: pub u8, \n    // new_root: pub [u8; 32]\n\n\n    ) {\n        std::verify_proof_with_type(\n            verification_key,\n            proof,\n            public_inputs,\n            0x0,\n            HONK_IDENTIFIER,\n        );\n        let root_index_in_inputs = 0;\n        let trie_key_index_in_inputs = 32;\n        let trie_key_new_index = public_inputs[64] as u32;\n        let new_root_in_inputs = 65;\n        assert(trie_key_new_index == 3);\n        // println(f\"key index: {trie_key_index_in_inputs}\");\n    // let mut parent: [u8; 32] = root;\n    // let mut prefix_length_limb: u8 = trie_key_initial_limb_index;\n    // for i in 0 .. MAX_PATH_LEANTH {\n    //     if (i < node_length) {\n    //         if nodes[i].node_type == 0 { // branch node\n    //             let h = calculate_branch_hash(nodes[i]);\n    //             assert(h == parent);\n    //             let prefix_length_byte: u8 = prefix_length_limb/2;\n    //             let mut index = trie_key[prefix_length_byte];\n    //             if prefix_length_limb % 2 == 0 {\n    //                 index = index >> 4;\n    //             } else {\n    //                 index = index - (index >> 4) * 0x10;\n    //             }\n    //             parent = nodes[i].rows[index];\n    //             prefix_length_limb += 1;\n    //             h.for_each(|x| {\n    //                 print(f\"{x}, \");\n    //             });\n    //             println(\"\");\n    //         } else if nodes[i].node_type == 1 {\n    //             // TODO extension nodes\n    //         } else {\n    //             assert(false);\n    //         }\n    //     }\n    // }\n    // println(\"new root:\");\n    // parent.for_each(|x| {\n    //     print(f\"{x}, \");\n    // });\n    // println(\"\");\n    // assert(trie_key_final_limb_index == prefix_length_limb);\n    // assert(new_root == parent);\n}\n","path":"/Users/amirhossein/Desktop/room/fun/balance-check/recursive_circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}